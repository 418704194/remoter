---
title: "Guide to the remoter Package"
author: "Drew Schmidt"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_caption: true
    toc: true
    number_sections: true
    css: include/custom.css
    highlight: kate
bibliography: include/remoter.bib
csl: "include/ieee.csl"
vignette: >
  %\VignetteIndexEntry{Guide to the remoter Package}
  %\VignetteEngine{knitr::rmarkdown}
---

# Introduction

The **remoter** package [[@remoter]] allows you to control a remote R session from a local one.  The local R session can be in a terminal, GUI, or IDE such as RStudio.  The remote R session should be run in the background as, well, a server.

The package uses **ZeroMQ** [[@zeromq]] by way of the R package **pbdZMQ** [[@Chen2015pbdZMQpackage]] to handle communication.  Our use of pbdZMQ is specialized to client/server communications, but the package is very general.  For more details about **pbdZMQ** see the **pbdZMQ** package vignette [[@Chen2015pbdZMQvignette]].

The work for remoter was born out of the **pbdCS** package [[@pbdCS]], which is part of the Programming with Big Data in R (pbdR) project [[@pbdR2012]]. pbdR is a series of R packages that enable the usage of the R language on large distributed machines, like clusters and supercomputers.  See [r-pbd.org/](http://r-pbd.org)) for details.



## Installation

You can install the stable version from CRAN using the usual `install.packages()`:

```r
install.packages("remoter")
```

The development version is maintained on GitHub.  You can install this version using the `devtools` package:

```r
devtools::install_github("wrathematics/remoter")
```



## Philosophy

By default, all code entered to the client is executed on the batch SPMD servers.  There are several utility functions to help executing code on the local R session (see section below).  But you should assume that anything entered into the client session, *unless you explicitly specify to the contrary*, is executed only on the server.





# Example Usage

## Setup

Before beginning, you need to create your server.  To do this, you can:

1. ssh to your remote (you only need to do this once!)
2. Start a tmux session
3. Start R and run `remoter::server()` (see `?server` for additional options).  Or even better, run `Rscript -e remoter::server()` so the server dies if something goes wrong.
5. Detach your tmux session and log out.

Alternatively, you can run the R session in the background via something like:

```r
Rscript -e "remoter::server()" &
```



## Connecting to a Server

Once the server's ready, you can connect to it via:

```r
remoter::client("my.remote.address")
```

So for example, say you have set up a server (as described above) on EC2 with address `"ec2-1-2-3-4.compute-1.amazonaws.com"`, listening on port `56789`. Then you would run:

```r
remoter::client("ec2-1-2-3-4.compute-1.amazonaws.com", port=56789)
```

Alternatively, you can set up the server on your local machine just to see how it works.  In that case, you can use the "remote"" address `"localhost"`. If you're using an actually remote machine though, make sure  you forward your port on the server-side before trying to connect to it.



## Utility Functions

There are a few utility functions available that have to do with handling execution of things locally or moving data between client and server.

By default, all commands entered inside of the client are executed on the server.  If you need to do some things in the local R session, you can kill the client and just reconnect when you're ready. Alternatively, you can use the `lsc()`, `rmc()`, and `evalc()` functions.  These are client versions of `ls()`, `rm()`, and `eval()`.  

For moving data between client and server, there are the `s2c()` and `c2s()` commands which transfer from server to client and from client to server, respectively.  These functions transfer data that resides in the memory of the client/server.  To transfer a file in chunks (without reading all of it into memory), see `?pbdZMQ::zmq.sendfile` or `?pbdZMQ::zmq.recvfile`.



## Shutting Everything Down

From the client, enter the command `q()`.  Doing so will terminate the remote server, as well as close the client REPL.  This will not shut down the interactive R session that was hosting the client.  You can also disconnect the client from the server without shutting down the server by killing the client R session or executing `Ctrl-c` in the client.





# Problems, Bugs, and Other Maladies

The package should basically be useable, but there are some issues you might want to be aware of.

**Problem**: I lost my internet connection and the client is no longer sending messages.

**Solution**: Just `Ctrl+c` and re-run the `remoter::client()` call and you should be good to go.  If you set up the server as I described, then it is persistent (until you kill it with `q()`).  You can therefore also have multiple clients connect to the same server, and they will share the same data.  I actually kind of like this behavior, but I'm not married to it and I could probably be convinced to change it.
<br><br>


**Problem**: Can't use up/down arrow when using the client.

**Explanation**: That's because the client is just some R code sitting on top of the R REPL.  This shouldn't be a problem if you're using an IDE like RStudio or the like.
<br><br>


**Problem**: There's no security!

**Explanation**: There's currently an idiot's (i.e. mine) version of a password system available.  This can be made more sophisticated, and probably will be in the near future, probably using the new package **sodium**.  As for encrypting all communications, I'm not sure how important that is really, but there's a possibility using CurveZMQ.
<br><br>


**Problem**: Something else is wrong!

**Explanation**: I'm not surprised.  Please be so kind as to [file an issue](https://github.com/wrathematics/remoter/issues) describing the problem.




# Legal

&copy; 2015-2016 Drew Schmidt.

Permission is granted to make and distribute verbatim copies of this vignette and its source provided the copyright notice and this permission notice are preserved on all copies.

This package is heavily derived from the **pbdCS** package, the development for which was supported by the project *Harnessing Scalable Libraries for Statistical Computing on Modern Architectures and Bringing Statistics to Large Scale Computing* funded by the National Science Foundation Division of Mathematical Sciences under Grant No. 1418195.

Any opinions, findings, and conclusions or recommendations expressed in  this material are those of the authors and do not necessarily reflect the  views of the National Science Foundation.  The findings and conclusions in this article have not been formally disseminated by the U.S. Department of Health \& Human Services nor by the U.S. Department of Energy, and should not be construed to represent any determination or policy of University, Agency, Adminstration and National Laboratory.

This manual may be incorrect or out-of-date.  The authors assume no responsibility for errors or omissions, or for damages resulting from the use of the information contained herein.





# References
<script language="JavaScript" src="include/headers.js"></script>
